const fs = require('fs');
const path = require('path');
const sprintf = require('sprintf-js').sprintf;

var counter = 0;

// Private helper functions ////////////////////////////////////////////////////

// Zero padded numbers can only be represented as strings.
// If you don't know what a zero-padded number is, read the
// Wikipedia entry on Leading Zeros and check out some of code links:
// https://www.google.com/search?q=what+is+a+zero+padded+number%3F

const zeroPaddedNumber = (num) => {
  return sprintf('%05d', num);
};

const readCounter = (callback) => {
  fs.readFile(exports.counterFile, (err, fileData) => {
    if (err) {
      callback(null, 0);
    } else {
      callback(null, Number(fileData));
    }
  });
};

const writeCounter = (count, callback) => {
  var counterString = zeroPaddedNumber(count);
  fs.writeFile(exports.counterFile, counterString, (err) => {
    if (err) {
      throw ('error writing counter');
    } else {
      callback(null, counterString);
    }
  });
};

// Public API - Fix this function //////////////////////////////////////////////
// Your first goal is to save the current state of the counter to the hard drive, so it's persisted between server restarts. Do this by rewriting getNextUniqueId to make use of the provided 'readCounter' and 'writeCounter' functions.
// Use the unique id generated by getNextUniqueId to create a file path inside the dataDir.
// in path of datastore/data, create txt files with unique id's (0001, 0002....).


exports.getNextUniqueId = (callback) => {
  readCounter((err, count) => {
    writeCounter(count + 1, (err, idString) => {
      callback(err, idString);
    });
  });
  // return zeroPaddedNumber(counter);
  // 1) should use error first callback pattern
  // 2) should give an id as a zero padded string
  // 3) should give the next id based on the count in the file
  // 4) should update the counter file with the next value

  // it('should use error first callback pattern', (done) => {
  //   counter.getNextUniqueId((err, id) => {
  //     expect(err).to.be.null;
  //     expect(id).to.exist;
  //     done();
  //   });
  // });

  // readCounter((err, data) => {
  //   if (err) {
  //     callback(null, data);
  //   } else {
  //     data = data + 1;
  //     writeCounter(data, (err, id) => {
  //       if (err) {
  //         throw ('error writing unique Id');
  //       } else {
  //         callback(err, id);
  //       }
  //     });
  //   }
  // });

  // counter = counter + 1;


};



// Configuration -- DO NOT MODIFY //////////////////////////////////////////////

exports.counterFile = path.join(__dirname, 'counter.txt');
